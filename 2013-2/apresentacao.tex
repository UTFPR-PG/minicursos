\documentclass[size=14pt,
style=paintings
%style=aggie
%style=bframe
%style=ciment
%style=elcolors
%style=fyma blue
%style=fyma brown
%style=fyma gray
%style=fyma green
%style=fyma orange
%style=horatio
%style=husky
%style=ikeda
%style=jefka blue
%style=jefka brown
%style=jefka seagreen
%style=jefka white
%style=klope blackwhite
%style=klope bluewater
%style=klope pastelflower
%style=klope spring
%style=paintings charon
%style=paintings europa
%style=paintings goldengate
%style=paintings holywood
%style=paintings lamentation
%style=paintings maythird
%style=paintings moitessier
%style=paintings pearlearring
%style=paintings skater
%style=paintings syndics
%style=pazik brown
%style=pazik red
%style=sailor chocolate
%style=sailor cocktail
%style=sailor river
%style=sailor sea
%style=sailor wine
%style=simple
]{powerdot}

%\pdsetup{palette=HolyWood}

\usepackage[utf8]{inputenc}
\usepackage{qtree}

\title{Programação Dinâmica\\Algoritmo CYK\\}
\author{Daniel Lopes \and Fabiano Rosas}
\date{Agosto, 2013}

\begin{document}
\maketitle

%%-------------------------------------------------------------------------------------
\begin{slide}{Contextualização}
\onslide{2-}{Gramática livre de contexto}

\onslide{8-}{Forma Normal de Chomsky}

\onslide{11-}{Reconhecimento de uma palavra}

\vspace{2cm}
\onslide*{3-7}{\textbf{G} =  (V, T, P, S), onde:}

\onslide*{4-7}{\textbf{V} é o conjunto de símbolos não terminais.}

\onslide*{5-7}{\textbf{T} é o conjunto de símbolos terminais.}

\onslide*{6-7}{\textbf{P} é o conjunto das regras de produção.}

\onslide*{7-7}{\textbf{S} é o conjunto dos símbolos iniciais.}
%----
\onslide*{9-10}{\textbf{A} $\rightarrow \alpha$}

\onslide*{10-10}{\textbf{A} $\rightarrow \textbf{BC}$}
%----
\twocolumn
{
\onslide*{12-}{
\textbf{G} = (V, T, P, S)

V = \{S,A,B\}

T = \{a,b\}

P = \{S $\rightarrow$ AB,

\indent\hspace{1.2cm}A $\rightarrow$ a,

\indent\hspace{1.2cm}B $\rightarrow$ b\}
}}
{
\onslide*{13-}{\textbf{ab:}}
\onslide*{14}{\Tree [.S A B ]}
\onslide*{15}{\Tree [.S [.A a ] B ]}
\onslide*{16}{\Tree [.S [.A a ] [.B b ]]}
}

\end{slide}
%%-------------------------------------------------------------------------------------
\begin{slide}{Definição do problema}
\vspace{2.5cm}
\begin{quotation}
Dada uma gramática livre de contexto \textbf{G}, na forma normal de Chomsky e uma \textit{string} \textbf{s} de tamanho \textbf{n}.
\newline
\newline
\indent\indent \textbf{G} pode gerar \textbf{s}?
\end{quotation}
\end{slide}
%%-------------------------------------------------------------------------------------
\begin{slide}{Abordagens intuitivas}
\vspace{2cm}
\twocolumn{
S $\rightarrow$ BA
    
B $\rightarrow$ b

A $\rightarrow$ a

A $\rightarrow$ AB

B $\rightarrow$ CD

C $\rightarrow$ c

D $\rightarrow$ d
}
{
\onslide{2-}{\textbf{bacd:}}
\onslide*{3}{\Tree [.S [.B b ] [.A a ]]}
\onslide*{4}{\Tree [.S [.B b ] [.A [.A a ] [.B b ]]]}
\onslide*{5-}{\Tree [.S [.B b ] [.A [.A a ] [.B [.C c ] [.D d ]]]]}
}
\end{slide}
%%-------------------------------------------------------------------------------------
\begin{slide}{Programação dinâmica}
\vspace{1.5cm}
\twocolumn{
\onslide*{1-}{\Tree[.S [.A [.B [.C c ] [.D d ] ] [.C c ] ] [.B b ] ]}
}
{
\onslide*{2}{
\Tree [.C c ]
\Tree [.D d ]
\Tree [.B b ]
}

\onslide*{3}{
\Tree [.B [.C c ] [.D d ] ]
}

\onslide*{4}{

\Tree [.A [.B [.C c ] [.D d ] ] [.C c ] ]
}
}
\end{slide}
%%-------------------------------------------------------------------------------------
\section{CYK}
%%-------------------------------------------------------------------------------------
\begin{slide}{Cocke–Younger–Kasami}
\vspace{1cm}
\textbf{s} $\in$ L(\textbf{G}) $\Rightarrow$ $\exists$ A $\rightarrow$ BC $\in$ \textbf{P}/ B é um não terminal que gera algum prefixo de \textbf{s}, C é um não terminal que gera um sufixo de \textbf{s}.
\vspace{1.5cm}
\begin{center}
\onslide{2-}{\Large \textbf{l} + \textbf{r} = \textbf{s}}
\end{center}

\end{slide}
%%-------------------------------------------------------------------------------------
\section{Exemplo}
\section{Algoritmo}
%%-------------------------------------------------------------------------------------
\begin{slide}{Pseudocódigo}
\onslide*{2}{
let \textbf{S} be a string of \textit{n} characters: a1 ... an.

let the grammar contain \textit{r} nonterminal symbols R1 ... Rr.

let \textbf{P[n,n,r]} be an array of booleans.
}

\twocolumn[lcolwidth=0.8\linewidth]{
\onslide{3-}{
{\blue for each} i = 1 to \textbf{n}

\hspace{.3cm}{\blue for each} unit production \textbf{R $\rightarrow$ a}

\hspace{.6cm}P[i,1,j] = \textbf{true}
}}
{
\onslide{4-}{$\theta ( n )$}

\onslide{5-}{$\theta (\mid G\mid)$}

\onslide{6-}{$\theta (n\mid G\mid)$}
}

\twocolumn[lcolwidth=0.8\linewidth]{
\vspace{.5cm}
\onslide{7-}{
{\blue for each} i = 2 to n

\hspace{.3cm}{\blue for each} j = 1 to n-i+1

\hspace{.6cm}{\blue for each} k = 1 to i-1

\hspace{.9cm}{\blue for each} production \textbf{A $\rightarrow$ B C}

\hspace{1.2cm}if P[j,k,B] and P[j+k,i-k,C] then

\hspace{2cm}P[j,i,A] = \textbf{true}
}}
{
\vspace{.5cm}
\onslide{8-}{$\theta ( n )$}

\onslide{9-}{$\theta ( n )$}

\onslide{10-}{$O ( n )$}

\onslide{11-}{$\theta (\mid G\mid)$}

\onslide{12-}{$\theta (n^3\mid G\mid)$}
}

\twocolumn[lcolwidth=0.8\linewidth]{
\onslide{13-}{
\vspace{.5cm}
{\blue if} any of P[1,n,x] is true {\blue then}

\hspace{.4cm}s \textbf{is} member of language

{\blue else}                     
      
\hspace{.4cm}s \textbf{is not} member of language
}}
{
\vspace{.5cm}
\onslide{14-}{$\theta ( 1 )$}

\onslide{15-}{$\theta ( 1 )$}
}

\end{slide}
%%-------------------------------------------------------------------------------------
\begin{slide}{Complexidade CYK}
\vspace{2.5cm}
\centering  {\Huge $O(n^3\mid G\mid)$}
\end{slide}
\end{document}